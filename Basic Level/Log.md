# Log

- B1001   //

- B1002   可优化

- B1003   找规律（条件2的两个x相同）

- B1004   注意格式输入

- B1005   段错误，数组开得太小？

- B1006   sprintf(arr, "%d" ,n);把数字n存到字符串数组中

- B1007   for(int i=2; i<=sqrt(num); i++) 一对一对移动

- B1008   循环右移记得移动距离取余

- B1009   while(scanf("%s",str)!=EOF)处理字符串   for(int i=k-1; i>=0; i--)倒序

- B1010  

    while(scanf("%d%d",&n[k1++],&m[k2++])!=EOF);
    	 int k=k1-1;
    	 进行空格的格式确认时，可以将空格先输入成&等来看格式是否正确

- B1011   [-2^32,2^32]用long long，同时输入时改成%lld

- B1012   //

- B1013   利用while(1)找出第四个测试点为(9993,10000)，发现题意为找第9993到10000之间的素数，而代码实现为遍历了10000以内的素数，从而进行改正。另外格式的问题需从简到繁进行累加制造。

- B1014   字符串匹配到相同的字母再进行数字的转换，注意匹配的字母具有一定的范围，并不是A~Z，如题目中0-9、A-N代表0-23点，所以在O-Z以及其他非法字符的匹配是不计算在内的，不计为正确的匹配。

- B1015   排序

    ```
    #include <algorithm>
    using namespace std;
    bool cmp(Student a, Student b)
    {
    	if(a.sc!=b.sc)
    		return a.sc > b.sc;
    	else if(a.de!=b.de)
    		return a.de > b.de;
    	else
    		return a.no < b.no;
    }
    ```

- B1016   sum = sum*10+a;

- B1017   不够除、除尽、被除位为0、被除数比除数小、首位商有0

- B1018   将剪刀石头布看成0、1、2，之间胜负根据数字的相减结果得到并进行归类。注意最终按照字典序BCJ来输出不唯一的解

    ```
    	scanf("%d\n",&n);   //输入n组两个字符的组合
    	p1 = getchar();     //   3
    	getchar();          //   C J
        p2 = getchar();     //   C B
    	getchar();          //   J c
    ```

- B1019   运行超时可能是陷入了无限循环，考虑边界点的特殊值进行测试。本题的黑洞点6174就是一个特殊的点，将while改成do while即可解决。

    ```
    //将字符串转换为数字 atoi(ascii to integer)  头文件stdlib
    	atoi(tmp);
    //讲数字转换为字符串 sprintf
    	sprintf(str,"%04d",num);
    ```

- B1020  第二个测试点：1 1 1 0

- B1021   //

- B1022   计算N进制时用do while较好

- B1023   输入数字时就转换为字符串形式

- B1024   

- B1025   

- B1026   四舍五入：time = (int)(x+0.5)>(int)x ? (int)(x+1):(int)x;

- B1027   找规律的题先进行纸头计算

- B1028   测试点3：输入数据均不合理

    ```
    //结构体构造函数
    struct Per{
    	char name[10];
    	int year;
    	int month;
    	int day;
    	Per(){}
    	Per(int _year,int _month, int _day):year(_year),month(_month),day(_day){}
    }per[101000];
    ```

- B1029   

    ```
    //单个字符大小写转换
    input[i] = toupper(input[i]);   //转大写
    output[i] = tolower(output[i]);   //转小写
    //整个字符串大小写转换   不是标准C库函数，只能在VC中使用，在linux gcc环境下需要自行定义这个函数。
    strupr(input);
    strlwr(output);
    //字符串去重hash
    ```

- B1030

- B1031   

    ```
    //要求输入N和N个字符串   要加上\n
    	scanf("%d\n",&N);
    	for(int i=0; i<N; i++)
    		gets(id);
    ```

- B1032   下标和从1开始的序号要区别开来

- B1033   第2行输入的文字串非空可知第一行可能为空   “,”、“.”、“-”、“+”（代表上档键）

- B1034   

- B1035

- B1036   四舍五入col = int(N/2.0+0.5)>int(N/2.0) ? int(N/2.0+0.5) : int(N/2.0);

- B1037   最后一个用例相等时输出0.0.0，直接换算到最小单位加减比较方便

- B1038   Hash

- B1039   若[0-9]、[a-z]、[A-Z]中进行统计，可以写一个change()函数，将字符与数组num[62]一一对应进行累计

- B1040

- B1041   //

- B1042   //

- B1043   //

- B1044

- B1045

- B1046   //

- B1047   //

- B1048   多写几个if并无大碍   注意点：B的长度小于A时要将B前端补零后再进行加密，即进行加密时以最长的为准。   对计算的输出一步步验证。

- B1049   找规律(N-i)*(i+1)

    ```
    //为防止(N - i) * (i + 1) int类型可能会溢出，把它放在double后面就可以防止溢出
    //另外若写成两句话，即先定义(N - i) * (i + 1)为long long类型再乘以a[i]也不通过用例，不知为何？
    //尽量不要写中间变量，直接带入
    sum += a[i] * (N - i) * (i + 1);
    ```

- B1051   double保留两位小数时，若数字很小着眼于局部，如-0.00001，这个数字在输出时保留两位变成-0.00这是不对的输出，正确的应该只输出0.00而不带负号

    ```
    if(A>-0.005 && A<0)
    	printf("0.00");
    ```


- B1052
- B1053   输出百分比%%，(double)强制转换
# Log

- B1001   //

- B1002   可优化

- B1003   找规律（条件2的两个x相同）

- B1004   注意格式输入

- B1005   段错误，数组开得太小？

- B1006   sprintf(arr, "%d" ,n);把数字n存到字符串数组中

- B1007   for(int i=2; i<=sqrt(num); i++) 一对一对移动

- B1008   循环右移记得移动距离取余

- B1009   while(scanf("%s",str)!=EOF)处理字符串   for(int i=k-1; i>=0; i--)倒序

- B1010  

    while(scanf("%d%d",&n[k1++],&m[k2++])!=EOF);
    	 int k=k1-1;
    	 进行空格的格式确认时，可以将空格先输入成&等来看格式是否正确

- B1011   [-2^32,2^32]用long long，同时输入时改成%lld

- B1012   //

- B1013   利用while(1)找出第四个测试点为(9993,10000)，发现题意为找第9993到10000之间的素数，而代码实现为遍历了10000以内的素数，从而进行改正。另外格式的问题需从简到繁进行累加制造。

- B1014   字符串匹配到相同的字母再进行数字的转换，注意匹配的字母具有一定的范围，并不是A~Z，如题目中0-9、A-N代表0-23点，所以在O-Z以及其他非法字符的匹配是不计算在内的，不计为正确的匹配。

- B1015   排序

    ```
    #include <algorithm>
    using namespace std;
    bool cmp(Student a, Student b)
    {
    	if(a.sc!=b.sc)
    		return a.sc > b.sc;
    	else if(a.de!=b.de)
    		return a.de > b.de;
    	else
    		return a.no < b.no;
    }
    ```

- B1016   sum = sum*10+a;

- B1017   不够除、除尽、被除位为0、被除数比除数小、首位商有0

- B1018   将剪刀石头布看成0、1、2，之间胜负根据数字的相减结果得到并进行归类。注意最终按照字典序BCJ来输出不唯一的解

    ```
    	scanf("%d\n",&n);   //输入n组两个字符的组合
    	p1 = getchar();     //   3
    	getchar();          //   C J
        p2 = getchar();     //   C B
    	getchar();          //   J c
    ```

- B1019   运行超时可能是陷入了无限循环，考虑边界点的特殊值进行测试。本题的黑洞点6174就是一个特殊的点，将while改成do while即可解决。

    ```
    //将字符串转换为数字 atoi(ascii to integer)  头文件stdlib
    	atoi(tmp);
    //讲数字转换为字符串 sprintf
    	sprintf(str,"%04d",num);
    ```

- B1020  正整数：int   正数：double   注意看是正整数还是正数。需求可以大于库存

- B1021   //

- B1022   计算N进制时用do while较好

- B1023   输入数字时就转换为字符串形式

- **B1024(科学计数法20)**   分情况讨论逐个解决（指数小于零，指数大于零，还有小数点，没有小数点，第一位是零，第一位不是零，第一位及后面几位都是零）>> 仍需优化

- **B1025(反转链表25)**   题目给出的链表节点有可能是无效节点，需要进行筛选（给有效节点一个order）。题目要求是每K个节点进行反转。“-1”的输出需要另外考虑，不然会输出"-00001"。

    ```
    struct Node{
    	int address, data, next;   //address为编号(地址)
    	int order;   //在链表上的序号，用于筛选无效结点
    }node[maxn];   //所有输入数据的编号与下标一一对应，再通过order排序筛选出有效节点
    ```

- B1026   四舍五入：time = (int)(x+0.5)>(int)x ? (int)(x+1):(int)x;

- B1027   找规律的题先进行纸头计算

- B1028   测试点3：输入数据均不合理

    ```
    //结构体构造函数
    struct Per{
    	char name[10];
    	int year;
    	int month;
    	int day;
    	Per(){}
    	Per(int _year,int _month, int _day):year(_year),month(_month),day(_day){}
    }per[101000];
    ```

- B1029   

    ```
    //单个字符大小写转换
    input[i] = toupper(input[i]);   //转大写
    output[i] = tolower(output[i]);   //转小写
    //整个字符串大小写转换   不是标准C库函数，只能在VC中使用，在linux gcc环境下需要自行定义这个函数。
    strupr(input);
    strlwr(output);
    //字符串去重hash
    ```

- **B1030(完美数列25)**    运用二分法，upper_bound()，寻找第一个超过m * p的数。最后一个测试点为大数>> `long long x = (long long)a[i]*p;`记得强制转换

    ```
    //输入范围left/right为[0,n]
    while(left<right) {
    mid = (left+right)/2;
    if(x>=a[mid])
    left = mid + 1;
    else
    right = mid;
    }
    ```


- B1031   

    ```
    //要求输入N和N个字符串   要加上\n
    	scanf("%d\n",&N);
    	for(int i=0; i<N; i++)
    		gets(id);
    ```

- B1032   下标和从1开始的序号要区别开来

- **B1033(旧键盘打字)**   第2行输入的文字串非空可知第一行可能为空   “,”、“.”、“-”、“+”（代表上档键）

- **B1034(有理数四则运算)**   按照套路书写gcd(`return !b ? a : gcd(b, a%b)`)、reduction(分母小于0则上下取反、分子等于0则分母等于1、正常约分)、add、minu、multi、div、show(分母等于1则直接输出分子、假分数、真分数)等函数。int分母相乘时会达到long long，所以分子分母采用long long，函数的返回类型和传参类型也是long long，输入输出%lld。计算最大公因数时gcd是绝对值传入`d = gcd(abs(a.up), abs(a.down));`，调用abs函数时，若使用cmath的头文件PAT编译错误，使用cstdlib头文件`int abs(int i);`返回的是int类型，long long要使用STL algoritm中的abs函数。

- B1035

- B1036   四舍五入col = int(N/2.0+0.5)>int(N/2.0) ? int(N/2.0+0.5) : int(N/2.0);

- B1037   最后一个用例相等时输出0.0.0，直接换算到最小单位加减比较方便

- B1038   Hash

- B1039   若[0-9]、[a-z]、[A-Z]中进行统计，可以写一个change()函数，将字符与数组num[62]一一对应进行累计

- **B1040(有几个PAT)**   活用递推，PAT的个数等于左边P的个数乘以右边T的个数。为减小复杂度，可以计算出每一个位上左边P的个数(从左遍历)和右边T的个数(从右边遍历)。

    ```
    for(int i=0; i<len; i++) {
      if(i>0)
      	left[i] = left[i-1];
      if(str[i]=='P')
      	left[i]++;
    }
    ```

- B1041   //

- B1042   //

- B1043   //

- **B1044(火星数字)**   由数字输出字符串使用字符串数组，由字母转成数字可通过字符串数组的strstr()遍历获得下标。

    `strstr (str1, str2)`若str2是str1的子串，则返回str2在str1的首次出现的地址；如果str2不是str1的子串，则返回NULL。

- B1045

- B1046   //

- B1047   //

- B1048   多写几个if并无大碍   注意点：B的长度小于A时要将B前端补零后再进行加密，即进行加密时以最长的为准。   对计算的输出一步步验证。

- B1049   找规律(N-i)*(i+1)

    ```
    //为防止(N - i) * (i + 1) int类型可能会溢出，把它放在double后面就可以防止溢出
    //另外若写成两句话，即先定义(N - i) * (i + 1)为long long类型再乘以a[i]也不通过用例，不知为何？
    //尽量不要写中间变量，直接带入
    sum += a[i] * (N - i) * (i + 1);
    ```

- **B1050(螺旋矩阵)**   先求出输出矩阵的长宽，再对数据进行排序，将数字填入，再打印矩阵。把数字矩阵进行初始化memset(cstring)，使用while()循环，每次循环内再放入四个外围一圈填数的while()，每次外层while输出一圈。判断条件是是否超出边界，是否尚未填入数字。

- B1051   double保留两位小数时，若数字很小着眼于局部，如-0.00001，这个数字在输出时保留两位变成-0.00这是不对的输出，正确的应该只输出0.00而不带负号

    ```
    if(A>-0.005 && A<0)
    	printf("0.00");
    ```


- **B1052(卖个萌)**   测试点1、2分别是当存在0和小于0的表情个数时的测试点。所以要考虑n1\n2\n3\n4\n5要小于等于0，其次对于不同的输出情况记得都要加上\n。

- B1053   输出百分比%%，(double)强制转换

- **B1054(求平均值)**      注意要点：1、单个数字合法时，输出"number"而不是“numbers” 2、第一位非数字或符号为非法 3、其他位非数字或小数点为非法 4、小数点超过1个为非法 5、小数点后超过2位非法 6、第一位为符号，第二位为小数点非法 7、不在[-1000,1000]范围内非法 8、小数点在最后一位可通过。   

  自己的坑：`(str[0]<'0' || str[0]>'9')`为非法字符这句话一开始写成了`(str[0]<='0' && str[0]>='9')`，多了等于和&&

- B1055

- B1056   //

- B1057   当没有字母出现总和为0时，二进制后该题的答案为0个0，0个1（用while），而不是1个0，0个1（用do while）

- B1058   对于含有数字加字符加非有效字符的输入格式：如果不是第一行，则要先把上一行中的回车吸收掉，再加入相应的非有效字符和对应的%d，接着对于%d后面的空格也要吸收掉还能接收%c的输入。    字符数组的比较需要自行书写，若希望通过strcmp()函数进行对比，则需要在数组的末尾加上'\0'，使之变成字符串，才能进行比较。

- B1059   把结构体的下标作为编号

- B1060(爱丁顿数)   先从大到小排序，再遍历直到num[i]不在大于E+1，所求E即为i+1。

- B1061   //

- B1062(最简分数)   两个int相除变成double类型的，必须对被除数*1.0或强制转换(double)。要把D1、D2进行大小比较，从0遍历到最大值，选出最大公约数为1的数。

- B1063   //

- B1064   集合的使用

  ```
  #include <set>
  using namespace std;
  set <int> arr;
  arr.insert(f);
  for(set<int>::iterator it=arr.begin(); it!=arr.end(); it++)
  	{
  		if(it!=arr.begin())
  			printf(" ");
  		else
  			printf("%d\n",arr.size());
  		printf("%d",*it);
  	}
  ```


- **B1065(单身狗)**   两两配对的人分别在各自的int数组中存入对方的编号，这样就可以相互检索了。
- B1066   //
- B1067   while(strcmp(gets(ispw),"#"))   当一行中只输入“#”时停止输入。  
- B1068
- B1069   将中奖的人放入一个字符串数组中，每次遍历是否已经中奖。定义next指向下一个中奖人的序号。
- B1070   注意每次结绳操作都为向下去整，而不仅是在最后输出时。

### issues

B1033(旧键盘打字)、B1035(插入与归并)、B1045(快速排序)、B1055(集体照)、B1068(万绿丛中一点红)